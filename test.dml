/*
 * Various tests, not including gradient checks.
 *
 * Namespace requirements:
 *  - "conv" available via `source("conv.dml") as conv`.
 *  - "conv_simple" available via `source("conv_simple.dml") as conv_simple`.
 *  - "test_util" available via `source("test_util.dml") as test_util`.
 *  - All dependencies of above sources.
 */
conv = function() {
  /*
   * Test for the `conv` functions.
   */
  print("Testing the conv functions.")

  # Generate data
  N = 2  # num examples
  C = 3  # num channels
  Hin = 5  # input height
  Win = 5  # input width
  F = 2  # num filters
  Hf = 3  # filter height
  Wf = 3  # filter width
  stride = 1
  pad = 1
  X = rand(rows=N, cols=C*Hin*Win, pdf="normal")

  # Create layer
  [W, b] = conv::init(F, C, Hf, Wf)

  # Forward
  [out, Hout, Wout] = conv::forward(X, W, b, C, Hin, Win, Hf, Wf, stride, stride, pad, pad)
  [out_simple, Hout_simple, Wout_simple] =
    conv_simple::forward(X, W, b, C, Hin, Win, Hf, Wf, stride, stride, pad, pad)

  # Equivalency check
  out = matrix(out, rows=1, cols=N*F*Hout*Wout)
  out_simple = matrix(out_simple, rows=1, cols=N*F*Hout*Wout)
  for (i in 1:length(out))
    rel_error = test_util::check_rel_error(as.scalar(out[1,i]), as.scalar(out_simple[1,i]),
                                           1e-10, 1e-12)
}

im2col = function() {
  /*
   * Test for the `im2col` and `col2im` functions.
   */
  print("Testing the im2col and col2im functions.")

	# Generate data
  C = 3  # num channels
  Hin = 5  # input height
  Win = 5  # input width
  Hf = 3  # filter height
  Wf = 3  # filter width
  stride = 2
  pad = (Hin * stride - Hin + Hf - stride) / 2
  Hout = as.integer((Hin + 2 * pad - Hf) / stride + 1)
  Wout = as.integer((Win + 2 * pad - Wf) / stride + 1)
  x = rand(rows=C, cols=Hin*Win)

  # pad
  x_pad = conv::pad_image(x, Hin, Win, pad, pad)

  # im2col
  x_cols = conv::im2col(x_pad, Hin+2*pad, Win+2*pad, Hf, Wf, stride, stride)

  # col2im
  x_pad2 = conv::col2im(x_cols, Hin+2*pad, Win+2*pad, C, Hf, Wf, stride, stride, "none")

  # Equivalency check
  equivalent = test_util::all_equal(x_pad, x_pad2)
  if (!equivalent)
    print("ERROR: im2col and then col2im does not yield the original image.")
}

padding = function() {
  /*
   * Test for the `pad_image` and `unpad_image` functions.
   */
  print("Testing the padding and unpadding functions.")

  # Generate data
  C = 3  # num channels
  Hin = 5  # input height
  Win = 5  # input width
  pad = 3  # padding
  x = rand(rows=C, cols=Hin*Win)

  # Pad image
  x_pad = conv::pad_image(x, Hin, Win, pad, pad)
  
  # Check for padded rows & columns
  for (c in 1:C) {
    x_pad_slice = matrix(x_pad[c,], rows=Hin+2*pad, cols=Win+2*pad)
    for (i in 1:pad) {
      rowsum = sum(x_pad_slice[i,])
      colsum = sum(x_pad_slice[,i])
      if (rowsum != 0)
        print("ERROR: Padding was not applied to row " + i + ".")
      if (colsum != 0)
        print("ERROR: Padding was not applied to column " + i + ".")
    }
  }

  # Unpad image
  x1 = conv::unpad_image(x_pad, Hin, Win, pad, pad)

  # Equivalency check
  equivalent = test_util::all_equal(x, x1)
  if (!equivalent)
    print("ERROR: Padding and then unpadding does not yield the original image.")
}

