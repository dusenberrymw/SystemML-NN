/*
 * Max pooling layer.
 *
 * Namespace requirements:
 *  - "util" available via `source("util.dml") as util`.
 *  - All dependencies of above sources.
 */
forward = function(matrix[double] X, int C, int Hin, int Win, int Hf, int Wf,
                   int strideh, int stridew)
    return (matrix[double] out, int Hout, int Wout) {
  /*
   * Computes the forward pass for a 2D spatial max pooling layer.
   * The input data has N examples, each represented as a 3D volume
   * unrolled into a single vector.
   *
   * This implementation uses `im2col` internally for each image to
   * extract local image regions (patches) of each channel slice into
   * columns, and then performs max pooling over the patches to compute
   * the output maps.
   *
   * Inputs:
   *  - X: Input data matrix, of shape (N, C*Hin*Win).
   *  - C: Number of input channels (dimensionality of input depth).
   *  - Hin: Input height.
   *  - Win: Input width.
   *  - Hf: Filter height.
   *  - Wf: Filter width.
   *  - strideh: Stride over height.
   *  - stridew: Stride over width.
   *
   * Outputs:
   *  - out: Outputs, of shape (N, C*Hout*Wout).
   *  - Hout: Output height.
   *  - Wout: Output width.
   */
  N = nrow(X)
  Hout = as.integer((Hin - Hf) / strideh + 1)
  Wout = as.integer((Win - Wf) / stridew + 1)

  # Create output volume
  out = matrix(0, rows=N, cols=C*Hout*Wout)

  # Max pooling - im2col implementation
  parfor (n in 1:N) {  # all examples
    img = matrix(X[n,], rows=C, cols=Hin*Win)  # reshape
    img_maxes = matrix(0, rows=C, cols=Hout*Wout)  # zeros

    parfor (c in 1:C) {  # all channels
      # Extract local image slice patches into columns with im2col, of shape (Hf*Wf, Hout*Wout)
      img_slice_cols = util::im2col(img[c,], Hin, Win, Hf, Wf, strideh, stridew)

      # Max pooling on patches
      img_maxes[c,] = colMaxs(img_slice_cols)
    }

    out[n,] = matrix(img_maxes, rows=1, cols=C*Hout*Wout)
  }
}

backward = function(matrix[double] dout, int Hout, int Wout, matrix[double] X, int C,
                    int Hin, int Win, int Hf, int Wf, int strideh, int stridew)
    return (matrix[double] dX) {
  /*
   * Computes the backward pass for a 2D spatial max pooling layer.
   * The input data has N examples, each represented as a 3D volume
   * unrolled into a single vector.
   *
   * This implementation uses `im2col` and `col2im` internally.
   *
   * Inputs:
   *  - dout: Derivatives from upstream, of shape (N, C*Hout*Wout).
   *  - Hout: Output height.
   *  - Wout: Output width.
   *  - X: Input data matrix, of shape (N, C*Hin*Win).
   *  - C: Number of input channels (dimensionality of input depth).
   *  - Hin: Input height.
   *  - Win: Input width.
   *  - Hf: Filter height.
   *  - Wf: Filter width.
   *  - strideh: Stride over height.
   *  - stridew: Stride over width.
   *
   * Outputs:
   *  - dX: Gradient wrt X, of shape (N, C*Hin*Win).
   */
  N = nrow(X)
  
  # Create gradient volume
  dX = matrix(0, rows=N, cols=C*Hin*Win)
  
  # Gradient of max pooling - im2col implementation
  parfor (n in 1:N) {  # all examples
    img = matrix(X[n,], rows=C, cols=Hin*Win)  # reshape
    doutn = matrix(dout[n,], rows=C, cols=Hout*Wout)
    dimg = matrix(0, rows=C, cols=Hin*Win)

    parfor (c in 1:C) {  # all channels
      # Extract local image slice patches into columns with im2col, of shape (1*Hf*Wf, Hout*Wout)
      img_slice_cols = util::im2col(img[c,], Hin, Win, Hf, Wf, strideh, stridew)

      # Max pooling on patches to find indices of max elements for each patch
      img_slice_maxes = colMaxs(img_slice_cols)  # shape(1, Hout*Wout)

      # Route gradient back through maximum element in each patch
      dimg_slice_cols = matrix(0, rows=Hf*Wf, cols=Hout*Wout)
      parfor(j in 1:Hout*Wout) {
        img_slice_cols_max_ind = ppred(img_slice_cols[,j], as.scalar(img_slice_maxes[1,j]), "==")
        dimg_slice_cols[,j] = img_slice_cols_max_ind * doutn[c,j]  # shape (1*Hf*Wf, 1)
      }

      # Create gradient of image slice from patch columns with col2im, of shape (1, Hin*Win)
      dimg_slice = util::col2im(dimg_slice_cols, 1, Hin, Win, Hf, Wf, strideh, stridew, "add")
      dimg[c,] = matrix(dimg_slice, rows=1, cols=Hin*Win)
    }

    dX[n,] = matrix(dimg, rows=1, cols=C*Hin*Win)
  }
}

